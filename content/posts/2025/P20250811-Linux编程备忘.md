---
title: "Shell 脚本语法备忘"
date: 2025-08-11T12:46:44+08:00
draft: false
tags: ["Linux", "编程"]
categories: ["Linux"]
author: "Mitre"
ShowBreadCrumbs: false
cover:
    image: "images/2025/P20250811-linux-corver.png"
    alt: "图片描述"
    caption: "图片说明"
---

有什么技术问题问 AI, 它会立刻给你答案, 还有必要写技术博客吗?  
我觉得写一写是好的, 博客就是笔记, 看着很熟悉, 有助于加深对知识的掌握.  
如今 AI 编程能力强大, 我们要有一些知识储备才能驾驭它, 否则可能会被 AI 牵着鼻子走.  

当下, 对于程序员来说, 我认为必须具备:  
1. 架构能力(包括技术架构, 业务架构, 数据架构, 安全架构).  

2. 基本的读写代码能力.  

我们要有架构能力才能高效指导 AI 写代码. 架构能力需要我们系统学习(读书,学教程等)才能掌握.  
AI 写好了代码, 我们要 review. 因此读写代码能力也很重要.   


## 控制语句


### 条件判断（if/else）
```bash
if [ 条件表达式 ]; then
    命令
elif [ 条件表达式 ]; then
    命令
else
    命令
fi
```
例子:
```bash
#!/bin/bash
num=5
if [ $num -gt 10 ]; then
    echo "大于10"
elif [ $num -eq 10 ]; then
    echo "等于10"
else
    echo "小于10"
fi
```


### 多分支 (case)
```bash
case 变量 in
    模式1)
        命令
        ;;
    模式2|模式3)
        命令
        ;;
    *)
        默认命令
        ;;
esac
```
例子:
```bash
#!/bin/bash
read -p "输入y或n: " ans
case $ans in
    y|Y)
        echo "你选择了YES"
        ;;
    n|N)
        echo "你选择了NO"
        ;;
    *)
        echo "输入无效"
        ;;
esac
```

### 循环 (for)

```bash
# 语法 1 (列表):
for var in 值1 值2 值3; do
    命令
done

# 语法 2 (C 风格):
```bash
for ((i=1; i<=5; i++)); do
    命令
done
```

例子:  
```bash
# 语法 1 (列表):
# 遍历字符串列表
for fruit in apple banana orange; do
    echo "水果：$fruit"
done
# 遍历数字范围
for num in {1..5}; do
    echo "数字：$num"
done

# 语法 2 (C 风格):
for ((i=1; i<=3; i++)); do
    echo "数字: $i"
done
```

### 循环 (while)
```bash
while [ 条件 ]; do
    命令
done
```
例子:
```bash
count=1
while [ $count -le 3 ]; do
    echo "第$count次循环"
    count=$((count+1))
done
```

### 跳出与跳过

• break 结束当前循环  
• continue 跳过当前循环剩余部分, 进入下一轮  

例子:
```bash
for i in {1..10}; do
    if [ $i -eq 3 ]; then
        continue  # 跳过3
    fi
    if [ $i -eq 5 ]; then
        break     # 遇到5退出
    fi
    echo "i=$i"
done
```
结果:
```
i=1
i=2
i=4
```

### 组合控制
• `cmd1 && cmd2` → 如果 `cmd1` 成功执行 (返回值为 0), 则执行 `cmd2`  
• `cmd1 || cmd2` → 如果 `cmd1` 执行失败 (返回值非 0), 则执行 `cmd2`  
• `cmd1 ; cmd2` → 先执行 `cmd1`, 后执行 `cmd2`(不论 `cmd1` 是否成功)

总结:  
• `&&` → 前一个成功才执行下一个。  
• `||` → 前一个失败才执行下一个。  
• `;` → 顺序执行, 不管前一个命令是否成功。

例子:  
```bash
[ -f myfile.txt ] && echo "文件存在" || echo "文件不存在"

mkdir test_dir && cd test_dir || echo "创建目录失败"

echo "第一步"; echo "第二步"
```

## 条件运算符(conditional operators)
`test`, `[  ]`, `[[  ]]`(Bash 扩展语法) 都是条件运算符, 它们用于构建 `if`, `while` 等语句中的判断条件.    

绝大多数 `[ ]` 条件表达式 在 `[[ ]]` 中都能用, 而且更安全。   

如果写 Bash 脚本, 推荐统一用 `[[ ]]`。  
如果要写 POSIX 兼容脚本, 只能用 `[ ]`。   

条件运算符 主要分为三大类：  
字符串比较, 数值比较, 文件测试.  

### 字符串比较运算符:  
| Operator |	Meaning |	Example |
|---|---|---|
|=|	equal to|	[ "$str1" = "$str2" ]|
|!=|	not equal to|	[ "$str1" != "$str2" ]|
|-z|	**string is empty**|	[ -z "$str" ]|
|-n|	**string is not empty**|	[ -n "$str" ]|

### 数值比较运算符:  
| Operator| 	Meaning| 	Example| 
|---|---|---|
|-eq|	equal to|	[ "$a" -eq "$b" ]|
|-ne|	not equal to|	[ "$a" -ne "$b" ]|
|-gt|	greater than|	[ "$a" -gt "$b" ]|
|-lt|	less than|	[ "$a" -lt "$b" ]|
|-ge|	greater than or equal to|	[ "$a" -ge "$b" ]|
|-le|	less than or equal to|	[ "$a" -le "$b" ]|

### 文件测试运算符:  
|Operator|	Meaning	|Example|
|---|---|---|
|-e|	file exists	|[ -e file.txt ]|
|-f|	file exists and is a regular file|	[ -f file.txt ]|
|-d|	directory exists|	[ -d /path/dir ]|
|-s|	file exists and is not empty|	[ -s file.txt ]|
|-r|	file is readable|	[ -r file.txt ]|
|-w|	file is writable|	[ -w file.txt ]|
|-x|	file is executable|	[ -x script.sh ]|
|-L|	file is a symbolic link|	[ -L symlink ]|
|-nt|	file1 is newer than file2|	[ file1 -nt file2 ]|
|-ot|	file1 is older than file2|	[ file1 -ot file2 ]|

### 逻辑运算符:  
Operator|	Meaning|	Example
---|---|---
-a|	AND (both conditions true)|	[ "$a" -gt 0 -a "$b" -lt 10 ]
-o|	OR (at least one true)|	[ "$a" -eq 1 -o "$b" -eq 2 ]
!|	NOT (negation)|	[ ! -f file.txt ]
&&|	AND (preferred in [[ ]])|	[[ "$a" -gt 2 && "$b" -gt 2 ]], [ "$a" -gt 2 ] && [ "$b" -gt 2 ]
\|\|| OR| [[ "$a" -gt 2 \|\| "$b" -gt 2 ]], [ "$a" -gt 2 ] \|\| [ "$b" -gt 2 ]

• `[ ]` 中使用 `-a` (AND) 和 `-o` (OR) 组合条件, 可读性差且容易出错。  
• `[[ ]]` 中可以直接使用 `&&` 和 `||`。

###  模式匹配与正则
• `[ ]` 不支持通配符匹配 (仅支持字符串字面比较)。  
• `[[ ]]` 支持模式匹配 (`==` 可以匹配通配符, `=~` 可以匹配正则)。  
例子:  
```bash
# 模式匹配
[[ "hello" == h* ]] && echo "matched"  # 输出 matched  

# 正则匹配
[[ "abc123" =~ ^[a-z]+[0-9]+$ ]] && echo "regex matched"
```

## 函数 

### 函数定义 
```bash
# 写法 1
function func_name {
    commands
}

# 写法 2 (POSIX 兼容, 更通用)
func_name() {
    commands
}
```
> 注意:  
> 函数名建议使用小写, snake_case(蛇形命名法: 多个单词下划线分隔)  
> `function` 关键字在 Bash 中可选, 但在 POSIX Shell 中不能用。  

### 函数参数与调用
```bash
greet() {
    # $1 $2 $3 … 表示位置参数  
    echo "Name: $1"
    echo "Age: $2"

    # $# 表示参数个数
    echo "Total args: $#"
    
    # $@ 表示所有参数 (保持原始分隔)
    echo "All args (\$@): $@"
    
    # $* 表示所有参数 (作为一个整体字符串)
    echo "All args (\$*): $*"
}

greet "Alice" 20
```
### 返回值
返回退出状态码:  
用 `return <code>` 返回 0~255 的整数 (退出状态码, **0 表示成功**)  


```bash
check_num() {
    if [ $1 -gt 10 ]; then
        return 0    # 成功
    else
        return 1    # 失败
    fi
}

check_num 15 && echo "OK" || echo "FAIL"
```

返回数据:    
Bash 函数没有 return value 机制, 需要用 echo 或全局变量传值:   
```bash
sum() {
    # 标准错误, 不是返回值, 会直接输出到控制台
    echo "sum 函数开始计算." >&2
    
    local result=$(( $1 + $2 ))
    
    # 标准输出是返回值
    echo $result
    
    echo "sum 函数结束计算." >&2
}

total=$(sum 3 5)
echo "Sum is $total"
```
运行结果:  
```bash
sum 函数开始计算.
sum 函数结束计算.
Sum is 8
```

### 局部变量

使用 local 声明变量, 避免污染全局环境:
```bash
demo() {
    local msg="local variable"
    echo "$msg"
}

demo
echo "$msg"  # 空, 因为是局部变量
```

### 函数与 trap 结合 (清理资源)
函数 用于清理临时文件或处理退出信号:  
```bash
cleanup() {
    echo "Cleaning up..."
    rm -f /tmp/mytempfile
}

# 脚本退出时执行
trap cleanup EXIT  
```
补充说明:  
```bash
trap 'commands' SIGNALS
```
- 'commands' 是在捕获到指定信号时执行的命令串（最好用单引号包裹） 

- SIGNALS 是信号名（大写），或者事件

常见信号:  
信号名| 信号含义|    说明
---|---|----
SIGINT|   终端中断（Ctrl+C）|     用户按 Ctrl+C 触发
SIGTERM|  终止进程|     默认终止信号
SIGQUIT|  退出，产生 core dump|  用户按 Ctrl+\ 触发
SIGHUP|   挂断|   终端关闭时发送
EXIT|     脚本退出（任意原因）|   脚本退出时一定执行


## 变量扩展（variable expansion）
待更...

## 总结

总结文章要点...
