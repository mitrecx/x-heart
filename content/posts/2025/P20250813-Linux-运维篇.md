---
title: "Linux: 运维篇"
date: 2025-08-13T01:06:49+08:00
draft: false
tags: ["Linux"]
categories: ["Linux"]
author: "Mitre"
ShowBreadCrumbs: false
cover:
    image: "images/2025/P20250811-linux-corver.png"
---

前两天写了 ["Linux: shell 脚本篇"]({{< relref "P20250811-Linux-shell脚本篇.md" >}}), 其中不涉及运维相关的内容, 因此新写了 "Linux: 运维篇" 作为补充.  

## 磁盘与文件信息
### df 命令 (disk free)  
df - 查看磁盘分区的空间使用情况
```bash
df -h

# 参数说明:
# -h 以人类可读的方式显示 (自动用 KB/MB/GB)
# -T 显示文件系统类型
# -i 查看 inode 使用情况 (避免 inode 用完导致无法写入)
```

### du 命令 (disk usage)  
du - 查看目录或文件所占空间  
```bash
du [选项] [文件/目录]
```
注意:   
`du` 显示的是磁盘实际占用大小, 可能和 `ls -l` 显示的文件大小不同, 因为磁盘按块分配空间 (即使文件很小也会占一个块)  


常用参数:  
参数|	含义|	示例
---|---|---
-h|	以人类可读方式显示 (KB/MB/GB)|	du -h /var/log
-s|	只显示总计 (summary), 不递归|	du -sh /var/log
-a|	显示目录和文件的大小|	du -ah /var/log
--max-depth=N|	限制目录递归深度|	du -h --max-depth=1 /var
-c|	显示总计 (最后一行 total)|	du -ch /var/log

常用组合:  
```bash
 # 查看 /var 目录占用空间
du -sh /var

# 按大小排序, 找出最大的 3 个目录
du -h --max-depth=1 /var | sort -hr | head -n 3
```
查询 /var 目录下占用空间最多的10个文件:  
```bash
find /var -type f -exec du -h {} + | sort -hr | head -n 3
# 解释:  
# -exec du -h {} +
# 对每个文件执行 du -h 计算占用空间, 以人类可读的格式输出

# 用 ls 代替 du 可以快很多 (直接取文件大小, 不统计磁盘块):
find /var -type f -exec ls -lh {} + | sort -k 5 -hr | head -n 3
# 解释:  
# sort -k 5 -rh
# -k 5 是按 ls -lh 输出的第 5 列 (文件大小) 排序
```


### mount 命令
`mount` 命令用于将一个存储设备 挂载 到 Linux 的目录树中.  
挂载点: 挂载点是一个已经存在的目录, 挂载后, 访问这个目录就是访问设备里的文件.  
```bash
mount [options] [device] [mount_point]
```
常用参数:  
参数	|作用
---|---
-t <fstype>|	指定文件系统类型 (如 ext4, xfs, vfat, ntfs, nfs)
-r|	只读挂载 (等同于 -o ro)
-w|	读写挂载 (默认)
-a|	按 /etc/fstab 配置挂载所有设备

例子:  
```bash
# 查看当前挂载情况
mount

#  挂载一个 NTFS 分区 (需要 ntfs-3g)
sudo mount -t ntfs-3g /dev/sdc1 /mnt/usb
# /dev/sdc1 是内核为物理磁盘的一个分区分配的设备文件名，来源于系统的硬件检测
# 插入一个硬盘/U 盘后，可以用 lsblk 或 fdisk -l 快速找到它的名字

# 挂载 NFS 共享目录
sudo mount -t nfs 192.168.1.23:/shared /mnt/nfs

# 卸载挂载点
sudo umount /mnt/data
# 或用设备名:
sudo umount /dev/sdc1
```

### stat
stat 命令用于显示文件或目录的详细信息，包括大小、权限、拥有者、创建/修改时间、inode 号等  

```bash
stat [选项] 文件或目录名
```
最常用的选项是 `-c` 自定义输出格式，用类似 %s 的占位符显示指定信息.  

例子:  
```bash
stat t.sh
```
结果:  
```text
  文件：t.sh
  大小：287       	块：8          IO 块：4096   普通文件
设备：fd03h/64771d	Inode：399798      硬链接：1
权限：(0664/-rw-rw-r--)  Uid：( 1000/   josie)   Gid：( 1000/   josie)
最近访问：2025-08-12 00:08:45.655705389 +0800
最近更改：2025-08-12 00:08:43.043596780 +0800
最近改动：2025-08-12 00:08:43.045596863 +0800
创建时间：2025-08-12 00:08:43.043596780 +0800
```
使用 `-c` 格式化输出: 
```bash
stat -c "Size: %s bytes, Modified: %y" t.sh
# 结果
# Size: 287 bytes, Modified: 2025-08-12 00:08:43.043596780 +0800
```

## 内存

### free
free 显示系统的内存使用情况.  
```bash
free [选项]
```
常用参数:  
参数| 作用
---|---
-h| 以人类可读格式显示（自动转换为 KB/MB/GB）
-s <秒>| 每隔指定秒数刷新显示内存信息

例子:  
```bash
free -h
```
结果: 
```text
              total        used        free      shared  buff/cache   available
Mem:          1.8Gi       1.3Gi       386Mi       2.0Mi       350Mi       560Mi
Swap:         2.0Gi       1.1Gi       907Mi
```
解释:
total: 总内存大小
used: 已使用的内存（不含缓存和缓冲）
free: 当前未使用的内存
shared: 多个进程共享的内存大小
buff/cache: 用作缓存和缓冲的内存，Linux 会尽量利用空闲内存做缓存提高效率
available: 预计可用内存大小（可以被新程序使用而不会触发交换）

重点说明: 
- **Linux 系统会用 空闲内存 做缓存（buff/cache）**，这部分内存可以在需要时释放给程序使用，所以不应该简单把缓存当成“已用”。  
- available 是一个比较准确反映剩余可用内存的字段。  
- Swap 是虚拟内存，物理内存用尽后系统会把部分内容写入交换区，通常应保持尽量少用 Swap，否则可能说明内存不足。  


### top/htop
`top` 命令可以实时监控系统的 CPU、内存、负载以及各个进程的资源占用情况。  
```bash
# 运行后会进入交互界面, 默认每隔 3 秒刷新一次。按 q 退出
top
```
输出内容: 上半部分是系统整体状态, 下半部分是进程列表。  

上半部分 (系统概况):
```text
top - 21:41:22 up 202 days, 22:02,  1 user,  load average: 0.00, 0.00, 0.00
Tasks: 125 total,   2 running, 123 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.8 us,  0.2 sy,  0.0 ni, 98.8 id,  0.0 wa,  0.2 hi,  0.0 si,  0.0 st
MiB Mem :   1871.0 total,    376.8 free,   1274.3 used,    380.2 buff/cache
MiB Swap:   2048.0 total,    895.1 free,   1152.8 used.    596.7 avail Mem
```
load average: 系统负载 (1 分钟, 5 分钟, 15 分钟)
Tasks: 进程总数和状态
%Cpu(s): CPU 使用率 (us 用户态, sy 内核态, id 空闲, wa 等待 I/O)
Mem/Swap: 内存与交换分区使用情况  

下半部分 (进程列表):
```text
    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
 972744 root      20   0  100688  10724   6616 S   0.7   0.6 170:59.67 AliYunDun
 972766 root      20   0  191960  39200  12624 S   0.7   2.0 392:44.74 AliYunDunMonito
```
PID: 进程 ID  
USER: 所属用户  
PR/NI: 优先级/优先级调整值  
VIRT/RES/SHR: 虚拟内存/常驻内存/共享内存  
%CPU/%MEM: 占用 CPU / 内存百分比  
TIME+: 运行时间  
COMMAND: 进程名  


常用交互操作(在 top 界面中可以按以下键):  
- P 按 CPU 占用排序
- M 按内存占用排序
- 1 显示每个 CPU 核心的使用率
- Shift + H 显示线程
- f/o 自定义显示字段

常用参数:  
```bash
top -p 1234       # 只监控 PID 为 1234 的进程
top -u username   # 只显示指定用户的进程
```

## 网络与传输
```sh
# 网络连通性测试
ping google.com

# 测试远程 80 端口是否开放
telnet example.com 80
# 端口开放的话, 返回结果中包含: Connected to example.com
# 端口没开放的话, 会提示: Connection refused 或 Connection timed out
```

### ssh 和 scp

```bash
ssh [参数] 用户名@主机地址 [命令]
```
如果指定了 命令, 则直接在远程执行该命令, 执行完后退出  

常用参数:  
参数| 作用
---|---
-p PORT| 指定端口
-i FILE| 指定私钥文件
-L |本地端口转发
-f |后台运行. 可以配合 -L 在后台开 tunnel
-T |不分配伪终端. 如果只是在远程执行命令, 不需要交互时 建议开启
-v |显示调试信息


例子:  
```bash
# 登录远程主机(默认端口22)
ssh user@192.168.1.10

# 指定端口登录
ssh -p 2222 user@192.168.1.10

# 使用私钥文件登录
ssh -i ~/.ssh/id_rsa user@192.168.1.10

# 在远程执行命令
ssh user@192.168.1.10 "uptime"

# 端口转发, 把本地 8080 端口的数据转发到远程主机的 80 端口
ssh -L 8080:localhost:80 user@192.168.1.10
```
配合配置文件使用, 编辑 `~/.ssh/config`:  
```text
Host myserver
    HostName 192.168.1.10
    User user
    Port 2222
    IdentityFile ~/.ssh/id_rsa
```
登录时只需要:  
```bash
ssh myserver
```

```bash
scp [参数] 源文件 目标文件
```
源文件和目标文件 都可以是：  
- 本地路径（如 /home/user/file.txt）
- 远程路径（如 user@host:/path/file.txt）

常用参数
参数| 说明
---|---
-r| 递归复制目录
-P| 指定远程服务器的 SSH 端口（注意是大写 P）
-C| 传输时启用压缩，提高速度

例子: 
```bash
# 从本地复制到远程, 开启压缩加速
scp -P 2222 -C file.txt user@remote:/tmp/

# 从远程复制到本地
scp user@remote:/path/to/remote.txt ./local.txt

# 复制整个目录（加 -r）: 把本地的 mydir 目录（及里面的所有文件）复制到远程 /path/to/
scp -r mydir user@remote:/path/to/
```

注意事项
- scp 传输时会占用 SSH 带宽，如果传输大文件速度慢，可以考虑 `rsync`。  
- 默认不会提示是否覆盖文件，直接覆盖。  

### rsync
rsync 是一个非常强大的文件同步和传输工具，它既可以在 本地 同步文件，也可以通过 SSH 在 远程主机之间同步 文件。  

`rsync` 传输速度快的原因:  
1. 增量同步   
- rsync 会先比较源文件和目标文件的差异，只传输 修改过的部分，而不是整个文件。
- 对比 scp：scp 总是完整传输整个文件，即使只改了一点内容也要全部传。  
2. 智能文件检测  
- rsync 会检测文件大小、时间戳甚至可以按 校验和 (checksum) 判断文件是否变化，避免重复传输。
3. 支持断点续传  
- 中断后重新传输，只传未完成的部分，不必从头再来。

常用参数
参数| 说明
---|---
-a| 归档模式，保留权限、时间戳、符号链接等
-v| 显示详细信息
-z| 传输时启用压缩
-r| 递归复制目录
--delete| 删除目标端多余文件，保持同步
-P| 显示进度，并支持中断续传
-e "ssh -p 2222"| 指定远程连接的 SSH 端口

例子:   
```bash
# 本地文件同步：
rsync -av /src/ /dest/

# 远程文件同步：(-avz 一般是标配)
rsync -avz /local/ user@remote:/remote/

# 从远程同步到本地，并删除目标多余文件
rsync -avz --delete user@remote:/home/user/data/ /home/user/data/  

# 使用自定义 SSH 端口
rsync -avz -e "ssh -p 2222" /home/user/data/ user@remote:/home/user/data/
```

总结  
`scp`：每次都完整传输文件，适合小文件或临时传输。  
`rsync`：增量传输 + 压缩 + 断点续传，适合大文件、大目录的同步任务。   


### curl
`curl` 用于与 URL 交互，支持 HTTP、HTTPS、FTP 等多种协议。  
```bash
curl [选项] URL
```

例子:  
```bash
# 把网页内容输出到终端(默认: 发送 GET 请求)
curl http://example.com
# 保存到文件(-o 文件名)
curl -o index.html http://example.com
# -O：保持远程文件名保存
curl -O http://example.com/index.html

# 发送 POST 请求
curl -X POST -d "username=tom&password=123" http://example.com/login
# -X：指定请求方法 (GET, POST, PUT, DELETE…)
# -d：请求体数据 (表单格式)

# JSON 请求
curl -X POST -H "Content-Type: application/json" \
     -d '{"name":"Tom","age":20}' \
     http://example.com/api/user
#	-H：添加请求头
# -d：请求体数据 (JSON 或其他格式)

# 带 Cookie
curl -b "sessionid=123456" http://example.com
# -b：发送 Cookie
# -c cookie.txt：把服务器返回的 Cookie 保存到文件

```

## 文件搜索 find
`find` 用于在目录树中查找符合条件的文件或目录。支持按文件名、类型、大小、时间、权限多种条件搜索，并可以对搜索出来的文件执行操作。  
```bash
find [搜索路径] [搜索条件] [操作]
```

常用搜索条件
条件|	说明|	示例
---|---|---
-name|	按文件名匹配（支持通配符 * ?）|	-name "*.txt"
-iname|	忽略大小写匹配文件名|	-iname "*.jpg"
-type|	按类型查找：f 文件、d 目录、l 符号链接|	-type d
-size|	按文件大小查找：+n 大于 n、-n 小于 n、n 等于 n（单位：c 字节，k KB，M MB，G GB）|	-size +10M
-mtime|	按修改时间查找：+n n 天前修改，-n n 天内修改|	-mtime -7
-atime|	按访问时间查找|	-atime +30
-perm|	按权限查找|	-perm 644
-user|	按属主查找|	-user root

常用操作  
操作|	说明|	示例
---|---|---
-print|	打印匹配的路径（默认行为，可省略）|	find . -name "*.log" -print
-exec|	对每个匹配文件执行命令|	find . -name "*.tmp" -exec rm -f {} \;
-delete|	删除匹配文件或目录|	find . -name "*.bak" -delete
-ls|	以类似 ls -l 的方式显示文件信息|	find /var -type f -ls

例子:  
```bash
# 按名称查找
find /tmp -name "*.txt"

# 查找最近 7 天修改过的文件
find /tmp -mtime -7

# 查找大于 100MB 的文件
find /tmp -type f -size +100M

# 删除目录下所有 .bak 文件
find /tmp -type f -name "*.bak" -delete

# 查找并执行命令(给当前目录下所有 .sh 文件加可执行权限)
find . -type f -name "*.sh" -exec chmod +x {} \;
# {}  表示 find 找到的每个文件或目录
# \;  表示对每个文件单独执行一次命令
find . -type f -name "*.log" -exec rm -f {} +
# +   表示把所有匹配文件一次性传递给命令执行（效率比 \; 更高）

# 结合管道使用(在日志文件中查找包含 “ERROR” 的行)
find /var/log -type f -name "*.log" | xargs grep "ERROR"
```
## 文本搜索 grep
文本搜索工具 `grep` 用于在文件或标准输入中查找符合模式的行, 支持正则表达式。  
```bash
grep [选项] '模式' 文件
```
模式：可以是普通字符串，也可以是正则表达式   
文件：要搜索的目标文件，如果不指定文件，则从标准输入读取   

常用选项
选项|	作用
---|---
-i|	忽略大小写匹配
-v|	反向匹配，即显示不包含模式的行
-r 或 -R|	递归搜索目录
-n|	显示匹配行的行号
-c|	只显示匹配行的数量
-l|	只显示包含匹配内容的文件名
-w|	匹配整词，而不是部分匹配
-e|	指定多个匹配模式
--exclude-dir=DIR| 搜索时排除子目录 DIR, 支持通配符
--exclude=PATTERN| 排除匹配模式 PATTERN 的文件, 支持通配符

例子:  
```bash
# 搜索 /var/log/output.log 中包含 “error” 的行
grep "error" /var/log/output.log

# 显示行号(-n)
grep -n "error" /var/log/output.log

# 反向匹配: 显示不包含 “INFO” 的行
grep -v "INFO" /var/log/output.log

# 在 ~/projects/ 目录及子目录中搜索文件中含 “TODO” 的行
grep -r "TODO" ~/projects/

# 统计匹配行数
grep -c "error" /var/log/output.log

# 多模式匹配: 匹配 “error” 或 “fail”
grep -e "error" -e "fail" /var/log/syslog

# 排除指定目录
grep -r --exclude-dir=logs "ERROR" /home/user/project
# 排除多个目录
grep -r --exclude-dir={logs,tmp} "ERROR" /home/user/project
# 支持通配符
grep -r --exclude-dir=tmp* "ERROR" /home/user/project
# 排除文件
grep -r --exclude="*.log" "ERROR" /home/user/project
grep -r --exclude=={"*.log","*.tmp"} "ERROR" /home/user/project
```



## 其他
### 系统信息: 
`uname` 查看系统类型、内核版本和机器架构   
```bash
uname -a
```
结果:  
```
Linux MyJosie 5.10.134-18.al8.x86_64 #1 SMP Fri Dec 13 16:56:53 CST 2024 x86_64 x86_64 x86_64 GNU/Linux
```

`hostnamectl` 用于 查看和管理 主机名以及系统信息  
```bash
hostnamectl
```
结果:  
```text
  Static hostname: MyJosie
        Icon name: computer-vm
          Chassis: vm
      Machine ID: 2a4ed15a10874d3b8ae4c1a79fec2dad
          Boot ID: 5a639c4fbae547fbaddfb220fb00eb3c
  Virtualization: kvm
Operating System: Alibaba Cloud Linux 3.2104 U11 (OpenAnolis Edition)
          Kernel: Linux 5.10.134-18.al8.x86_64
    Architecture: x86-64
```
•	Static hostname：静态主机名  
•	Icon name：图标名称  
•	Chassis：机箱类型，例如 vm、desktop、laptop  
•	Machine ID：系统唯一标识  
•	Virtualization：虚拟化类型（如 kvm、docker）  
•	Operating System：操作系统名称  
•	Kernel：内核版本  
•	Architecture：硬件架构  

### Linux 目录结构
Linux 的目录结构遵循 Unix 文件系统层次标准 (Filesystem Hierarchy Standard, FHS)，每个目录都有明确的用途  

常见目录及用途:  
目录|	作用
---|---
/bin|	基础用户命令，普通用户和单用户模式都可用的可执行程序，如 ls, cp, mv
/sbin|	系统管理命令，一般由 root 使用，如 ifconfig, reboot
/usr|	用户程序和共享数据，包含子目录 /usr/bin(普通用户的可执行程序), /usr/sbin, /usr/lib(程序库文件), /usr/lib, /usr/local(本地安装软件)
/lib|	核心共享库，支持 /bin 和 /sbin 的程序
/lib64|	64 位系统核心库
/etc|	系统配置文件，大部分配置文件都在这里，如网络配置、用户管理
/var|	可变数据，日志、邮件、缓存、数据库文件, /var/log(系统和服务日志)
/tmp|	临时文件，系统重启会清理
/home|	用户主目录，每个用户的个人文件和配置
/root|	root 用户的主目录
/opt|	**可选应用程序，第三方软件常安装在这里**
/dev|	设备文件，硬件和虚拟设备接口，如 /dev/sda
/proc|	内存文件系统，包含系统和进程信息，虚拟文件系统
/sys|	也是虚拟文件系统，显示内核和设备信息
/boot|	启动文件，内核、initramfs、GRUB 配置
/mnt|	临时挂载点，系统管理员自定义挂载使用


## 文本处理
文本处理: vim, sed, awk
后面另外写一篇吧
