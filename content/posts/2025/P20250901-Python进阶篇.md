---
title: "Python-进阶篇"
date: 2025-09-01T23:23:19+08:00
draft: false
tags: ["Python"]
categories: ["Python"]
author: "Mitre"
ShowBreadCrumbs: false
cover:
    image: "images/2025/P20250901-python.png"
---

## 类与实例
```python
class Person:
    """简单类示例"""
    species = "Homo sapiens"  # 类变量

    def __init__(self, name: str, age: int):
        self.name = name       # 实例变量
        self.age = age

    def greet(self) -> str:    # 实例方法
        return f"Hi, I'm {self.name}, {self.age} years old."

# 使用
p = Person("Alice", 30)
print(p.greet())  # Hi, I'm Alice, 30 years old.
print(Person.species)  # Homo sapiens
```
要点:  
- `__init__` 是 **初始化方法**, 在实例创建后被调用。  
- `self` 表示当前实例(`self`虽不是关键字, 但约定俗成), 方法调用时 Python 自动传入。  
- **类变量** 在所有实例间共享, 实例变量是每个实例独有的。  
 
 ### 实例变量/类变量/私有变量
实例变量 (Instance Variables): 属于特定实例（对象）的变量，每个实例都拥有自己独立的一份副本。  
特点：
- 在 `__init__` 构造函数 或 其他实例方法中 通过 `self.变量名` 定义  
- 每个对象的 实例变量值 可以不同

类变量 (Class Variables): 属于类本身的变量，被所有实例共享。  
特点：
- 在 类内部 但 在所有方法之外 定义  
- **所有对象 共享同一份数据**  

私有变量 (Private Variables): 在变量名前加 `双下划线 __` 的变量，Python 会对其进行名称修饰，实现一定程度的"私有化"。  
特点：  
- Python 会将其重命名为 `_类名__变量名`  
- 只是一种约定，并非真正的私有（Python 没有真正的私有变量） 

保护变量 (Protected Variables): 单下划线 _ 开头的变量。  


 ```python
class C:
    shared = []         # 类变量（可变，需小心）
    def __init__(self, x):
        self.x = x      # 实例变量
        self._hidden = 0   # 约定“受保护”
        self.__private = 1 # 名称改写(name mangling)

c = C(10)
print(c.shared)
 ```
 私有变量 `__name` 会被改写为 `_ClassName__name`，用于避免子类覆盖（不是绝对私密）。  

 ### 实例方法/类方法/静态方法
参数传递机制：
- 实例方法：Python 自动将 调用该方法的实例 作为第一个参数 `self` 传入。
- 类方法：Python 自动将 调用该方法的类作为第一个参数 `cls` 传入。
- 静态方法：Python 不会自动传入任何特殊参数。它的参数列表和普通函数一模一样。

访问权限：
- 实例方法：对实例和类都有完全访问权限。最常用、最灵活的方法。  
- 类方法：仅能看到所有类属性和其他类方法，看不到任何具体的实例。 
- 静态方法：与类完全隔离。它就像一个定义在类命名空间下的普通函数，不能直接使用 `self` 或 `cls`。  

```python
class A:
    count = 0

    def __init__(self):
        A.count += 1

    def instance_method(self):
        return self

    @classmethod
    def cls_method(cls):
        return cls.count

    @staticmethod
    def static_method(x, y):
        return x + y

a = A()
print(A.cls_method())
print(A.static_method(1, 2))
```
`@classmethod` 第一个参数是类 (`cls`)；常用于 **工厂方法** 或 **访问/修改类状态**。   
`@staticmethod` 不接收 `self` 或 `cls`；像普通函数，但放 在类命名空间下 便于组织。  
 

## 主要内容

### 小标题1

内容...

### 小标题2

内容...

## 总结

总结文章要点...
